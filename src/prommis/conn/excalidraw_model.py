# generated by datamodel-codegen:
#   filename:  Untitled-2024-11-16-0602.excalidraw
#   timestamp: 2024-11-17T05:45:28+00:00

from __future__ import annotations

import argparse
from collections import namedtuple
from io import IOBase
import json
import logging
import random
import re
import sys
import time
from typing import Any, Dict, List
import xml.etree.ElementTree as ET

from pydantic import BaseModel

_log = logging.getLogger(__name__)


class AppState(BaseModel):
    gridSize: int
    gridStep: int
    gridModeEnabled: bool
    viewBackgroundColor: str


class Model(BaseModel):
    type: str
    version: int
    source: str
    elements: List[Dict]
    appState: AppState
    files: Dict[str, Any]


class Diagram:
    def __init__(self, model: Model):
        self._m = model

    def write(self, outfile: IOBase, **dump_kw):
        data = self._m.model_dump()
        json.dump(data, outfile, **dump_kw)

    @classmethod
    def from_svg(cls, infile: IOBase) -> Diagram:
        tree = ET.parse(infile)
        root = tree.getroot()
        svg_ns = "{http://www.w3.org/2000/svg}"
        svg = root.find(svg_ns + "svg")
        if svg is None:
            raise ValueError("Cannot find <svg> tag")

        model = Model(
            type="excalidraw",
            version=2,
            source="idaes",
            elements=[],
            appState={
                "gridSize": 20,
                "gridStep": 5,
                "gridModeEnabled": False,
                "viewBackgroundColor": "#ffffff",
            },
            files={},
        )
        svg_xc_map = {}
        Bounds = namedtuple("Bounds", "x y width height")
        # Main loop
        for item in svg:
            # <g id="Unit_B">
            # <g class="shape" >
            # <rect x="286.000000" y="120.000000" width="132.000000"
            # height="66.000000" stroke="#0D32B2" fill="#F7F8FE"
            # class=" stroke-B1 fill-B6" style="stroke-width:2;" />
            # </g>
            # <text x="352.000000" y="158.500000" fill="#0A0F25" class="text-bold fill-N1"
            # style="text-anchor:middle;font-size:16px">leach_mixer</text></g>
            g_tag = svg_ns + "g"
            if item.tag == g_tag:
                item_id = item.get("id")
                xc_id = cls._element_id(item_id)
                svg_xc_map[item_id] = xc_id
                # Find node and text
                shape, line, text = None, None, None
                for subitem in item:
                    if subitem.tag == g_tag and subitem.get("class", "") == "shape":
                        is_shape = True
                        shape = subitem
                    elif subitem.tag == svg_ns + "text":
                        text = subitem
                rect_elt, text_elt = None, None
                now = int(time.time())
                if shape is not None:
                    rect_id = xc_id
                    rect_tag = svg_ns + "rect"
                    rect = shape.find(rect_tag)
                    if rect is None:
                        raise ValueError("Expected <rect> element for shape")
                    rb = Bounds(
                        *[
                            int(float(rect.get(c)))
                            for c in ("x", "y", "width", "height")
                        ]
                    )
                    rect_elt = {
                        "id": rect_id,
                        "type": "rectangle",
                        "x": rb.x,
                        "y": rb.y,
                        "width": rb.width,
                        "height": rb.height,
                        "angle": 0,
                        "strokeColor": "#000000",
                        "backgroundColor": "transparent",
                        "fillStyle": "solid",
                        "strokeWidth": 2,
                        "strokeStyle": "solid",
                        "roughness": 1,
                        "opacity": 100,
                        "roundness": {"type": 3},
                        "isDeleted": False,
                        "updated": now,
                        "locked": False,
                        "points": [],
                        "originalText": None,
                        "autoResize": True,
                        "lineHeight": 1.25,
                        "groupIds": [],
                        "frameId": None,
                        "link": None,
                        "boundElements": [],
                    }
                if text is not None:
                    # <text x="352.000000" y="158.500000" fill="#0A0F25"
                    # class="text-bold fill-N1"
                    # style="text-anchor:middle;font-size:16px">leach_mixer</text>
                    text_id = cls._element_id(item_id + "_label")
                    tb = Bounds(*[int(float(text.get(c))) for c in ("x", "y")] + [0, 0])
                    text_value = text.text.strip()
                    # get font size
                    text_style = text.get("style", "")
                    match = re.search(r"font-size:\s*(\d+)px", text_style)
                    if match:
                        font_size = int(match.group(1))
                    else:
                        font_size = 12
                    # calculate SVG margin from text to rectangle
                    margin = 4  # (tb.x - rb.x) // 2
                    # create element
                    text_elt = {
                        "id": text_id,
                        "type": "text",
                        "x": rb.x,
                        # center vertically
                        "y": rb.y + (rb.height / 2) - margin - (font_size / 2),
                        "width": rb.width,
                        "height": font_size * 1.5,
                        "angle": 0,
                        "strokeColor": "#000000",
                        "backgroundColor": "transparent",
                        "fillStyle": "solid",
                        "strokeWidth": 2,
                        "strokeStyle": "solid",
                        "roughness": 1,
                        "opacity": 100,
                        "groupIds": [],
                        "frameId": None,
                        "roundness": None,
                        "isDeleted": False,
                        "boundElements": None,
                        "updated": now,
                        "link": None,
                        "locked": False,
                        "text": text_value,
                        "fontSize": font_size,
                        "fontFamily": 6,
                        "textAlign": "center",
                        "verticalAlign": "middle",
                        "containerId": None,
                        "originalText": text_value,
                        "autoResize": True,
                        "lineHeight": 1,
                    }
                if text_elt and rect_elt:
                    rect_elt["boundElements"].append({"type": "text", "id": text_id})
                    text_elt["containerId"] = rect_id
                if rect_elt:
                    model.elements.append(rect_elt)
                if text_elt:
                    model.elements.append(text_elt)
        _log.debug(f"created {len(model.elements)} elements")
        return Diagram(model)

    # Alphabet for Excalidraw identifiers
    IDCHARS = (
        [chr(ord("A") + i) for i in range(26)]
        + [chr(ord("a") + i) for i in range(26)]
        + [chr(ord("0") + i) for i in range(10)]
    )

    @classmethod
    def _element_id(cls, item_id) -> str:
        "Generate random identifier in the style used by Excalidraw"
        items = random.choices(cls.IDCHARS, k=21)
        return "".join(items)


def main() -> int:
    p = argparse.ArgumentParser()
    p.add_argument("infile", metavar="input-file")
    p.add_argument("outfile", metavar="output-file")
    args = p.parse_args()

    # set up logging
    _log.setLevel(logging.DEBUG)  # XXX: for now
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter(fmt="{asctime} {levelname}: {message}", style="{"))
    _log.addHandler(h)

    # read and parse input
    _log.info(f"reading SVG from input file '{args.infile}'")
    with open(args.infile) as infile:
        diagram = Diagram.from_svg(infile)

    # write output
    with open(args.outfile, "w") as outfile:
        diagram.write(outfile, indent=2)
    _log.info(f"wrote JSON to output file '{args.outfile}'")

    return 0


if __name__ == "__main__":
    sys.exit(main())

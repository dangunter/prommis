# generated by datamodel-codegen:
#   filename:  Untitled-2024-11-16-0602.excalidraw
#   timestamp: 2024-11-17T05:45:28+00:00

from __future__ import annotations

import argparse
from io import IOBase
import json
import re
import sys
import time
from typing import Any, Dict, List, Optional
from uuid import uuid3, NAMESPACE_URL
import xml.etree.ElementTree as ET

from pydantic import BaseModel, Field


class Roundness(BaseModel):
    type: int


class BoundElement(BaseModel):
    id: str
    type: str


class StartBinding(BaseModel):
    elementId: str
    focus: float
    gap: int
    fixedPoint: None


class EndBinding(BaseModel):
    elementId: str
    focus: float
    gap: int
    fixedPoint: None


class Element(BaseModel):
    id: str
    type: str
    x: int
    y: int
    width: int
    height: int
    angle: int
    strokeColor: str
    backgroundColor: str
    fillStyle: str
    strokeWidth: int
    strokeStyle: str
    roughness: int
    opacity: int
    groupIds: List
    frameId: None
    index: str
    roundness: Roundness
    #    seed: int
    #    version: int
    #    versionNonce: int
    isDeleted: bool = False
    boundElements: Optional[List[BoundElement]]
    updated: int
    link: None = None
    locked: bool = False
    points: Optional[List[List[int]]] = Field(default_factory=list)
    # lastCommittedPoint: None = None
    # startBinding: Optional[StartBinding] = None
    # endBinding: Optional[EndBinding] = None
    # startArrowhead: None = None
    # endArrowhead: Optional[str] = None
    # elbowed: Optional[bool] = None
    originalText: str = None
    autoResize: bool = True
    lineHeight: float = 1.25


class AppState(BaseModel):
    gridSize: int
    gridStep: int
    gridModeEnabled: bool
    viewBackgroundColor: str


class Model(BaseModel):
    type: str
    version: int
    source: str
    elements: List[Element]
    appState: AppState
    files: Dict[str, Any]


class Diagram:
    PROMMIS_NS = "https://github.com/prommis/prommis/connectivity"

    def __init__(self, model: Model):
        self._m = model

    def write(self, outfile: IOBase, **dump_kw):
        data = self._m.model_dump()
        json.dump(data, outfile, **dump_kw)

    @classmethod
    def from_svg(cls, infile: IOBase) -> Diagram:
        tree = ET.parse(infile)
        root = tree.getroot()
        svg_ns = "{http://www.w3.org/2000/svg}"
        svg = root.find(svg_ns + "svg")
        if svg is None:
            raise ValueError("Cannot find <svg> tag")

        m = Model(
            type="excalidraw",
            version=2,
            source="idaes",
            elements=[],
            appState={
                "gridSize": 20,
                "gridStep": 5,
                "gridModeEnabled": False,
                "viewBackgroundColor": "#ffffff",
            },
            files={},
        )
        item_ids = {}
        rect_count = 0
        for item in svg:
            # <g id="Unit_B">
            # <g class="shape" >
            # <rect x="286.000000" y="120.000000" width="132.000000" height="66.000000" stroke="#0D32B2" fill="#F7F8FE" class=" stroke-B1 fill-B6" style="stroke-width:2;" />
            # </g>
            # <text x="352.000000" y="158.500000" fill="#0A0F25" class="text-bold fill-N1" style="text-anchor:middle;font-size:16px">leach_mixer</text></g>
            g_tag = svg_ns + "g"
            if item.tag == g_tag:
                item_id = item.get("id")
                xc_id = cls._element_id(item_id)
                item_ids[item_id] = xc_id
                shape, line, text = None, None, None
                for subitem in item:
                    if subitem.tag == g_tag and subitem.get("class", "") == "shape":
                        is_shape = True
                        shape = subitem
                    elif subitem.tag == svg_ns + "text":
                        text = subitem
                if shape is not None:
                    rect_tag = svg_ns + "rect"
                    rect = shape.find(rect_tag)
                    if rect is None:
                        raise ValueError("Expected <rect> element for shape")
                    now = int(time.time())
                    rect_elt = Element(
                        id=xc_id,
                        type="rectangle",
                        x=int(float(rect.get("x"))),
                        y=int(float(rect.get("y"))),
                        width=int(float(rect.get("width"))),
                        height=int(float(rect.get("height"))),
                        angle=0,
                        strokeColor="#1e1e1e",
                        backgroundColor="transparent",
                        fillStyle="solid",
                        strokeWidth=2,
                        strokeStyle="solid",
                        roughness=1,
                        opacity=100,
                        groupIds=[],
                        frameId=None,
                        index=f"a{rect_count}",
                        roundness={"type": 3},
                        boundElements=[],
                        updated=now,
                    )
                    m.elements.append(rect_elt)
                    if text is not None:
                        # <text x="352.000000" y="158.500000" fill="#0A0F25"
                        # class="text-bold fill-N1"
                        # style="text-anchor:middle;font-size:16px">leach_mixer</text>
                        text_id = cls._element_id(item_id + "_label")
                        text_value = text.text.strip()
                        m = re.match(r"font-size:(\d+)px", text.get("style", ""))
                        if m:
                            h = int(m.group(1))
                        else:
                            h = 12
                        w = 0.5 * h * len(text_value)
                        text_elt = Element(
                            id=text_id,
                            type="arrow",
                            x=int(float(text.get("x"))),
                            y=int(float(text.get("y"))),
                            width=w,
                            height=h,
                            angle=0,
                            strokeWidth=2,
                            strokeStyle="solid",
                            roughness=0,
                            opacity=100,
                            groupIds=[],
                            frameId=None,
                            index=f"a{rect_count}",
                            boundElements=[],
                            updated=now,
                            originalText=text_value,
                        )
                        m.elements.append(text_elt)
                    rect_count += 1
        return Diagram(m)

    @classmethod
    def _element_id(cls, item_id):
        url = f"{cls.PROMMIS_NS}/item_id"
        return str(uuid3(NAMESPACE_URL, url)).replace("-", "")[:21]


def main() -> int:
    p = argparse.ArgumentParser()
    p.add_argument("infile", metavar="input-file")
    p.add_argument("outfile", metavar="output-file")
    args = p.parse_args()

    # read and parse input
    with open(args.infile) as infile:
        diagram = Diagram.from_svg(infile)

    # write output
    with open(args.outfile, "w") as outfile:
        diagram.write(outfile, indent=2)

    return 0


if __name__ == "__main__":
    sys.exit(main())
